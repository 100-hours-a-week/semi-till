# TIL

## 날짜: 2024-12-10

### 스크럼

- 학습 목표 1 : QA 진행하기 🔥🔥
- 학습 목표 2 : Docker 복습하기기

### 새로 배운 내용

## 1️⃣주제 1: 컨테이너

### 컨테이너

- 소프트웨어를 실행하기 위한 표준화된 단위

### **특징**

1. 격리성
    - 각각의 컨테이너는 서로 격리되어 있고, 독립적인 환경을 제공한다.
    - 다양한 버전의 라이브러리/ 환경을 쉽게 관리할 수 있다.
2. 경량화
    - Virtual Machine 보다 훨씬 가볍다.
    - **host OS의 커널을 공유**하면서 **애플리케이션만 격리하기** 때문에 자원을 덜 소비한다.
        - VM: 각각 다른 OS를 하나 씩 실행한다.
      </br>
        
        > (호스트 OS의 커널을 공유한다) == **컨테이너가 애플리케이션을 실행할 때 호스트 OS의 커널을 그대로 사용한다. (커널 공유)**
        >
        > ### 커널
        > - 하드웨어와 소프트웨어 사이에서 통신을 관리, 시스템 자원(CPU,메모리,disk)를 관리한다. OS의 나머지 부분은 커널 위에서 동작한다
        >
        > ### 호스트 OS, 컨테이너
        >
        > - 호스트 OS : 물리적인 하드웨어에서 실행되는 OS
        > - 컨테이너 : ‘애플리케이션을 격리된 환경에서 실행하기 위해’ **호스트 OS의 커널을 그대로 사용 ⇒ 자체 커널을 가지지 않고, 호스트 OS가 이미 가지고 있는 커널을 활용한다.**
        >
        > ### WHY?
        >
        > 1. VM은 각 VM 별로 독립적인 OS와 커널을 가진다. 이는 자원을 많이 소비하고, 시작 시간이 길어지는 문제점이 있다. → 그래서 등장한 것이 컨테이너. 호스트 OS 커널을 공유하기 때문에 자원도 적게 소모하고, 실행이 빠르다.
        >
        > ### 즉,
        >
        > 1. 컨테이너는 독립적인 OS를 가지지 않고, 호스트 OS와 리소스를 공유한다.
        > 2. 컨테이너는 ‘애플리케이션’을 ‘격리’된 환경에서 실행할 수 있다. 
        
        
        > ### 컨테이너 자원 관리 방식
        >
        > 1. 네임스페이스 Namespaces
        >    - 각 컨테이너가 자신만의 독립적인 환경을 가질 수 있도록 돕는다.
        >    - ex)  PID 네임스페이스 : 자신만의 프로세스 목록을 갖도록 한다. → 하나의 컨테이너에서 실행되는 프로세스는 다른 컨테이너에서 볼 수 없다.
        >    - ex) 네트워크 네임스페이스 : 각 컨테이너가 자신만의 네트워크 인터페이스를 가지도록 한다. → 다른 컨테이너와 네트워크를 격리한다.
        > 2. 컨트롤 그룹 (Cgroups)
        >    - 호스트 OS의 커널에서 제공하는 기능이다.
        >    - 각 컨테이너가 소비하는 CPU, 메모리, 디스크 I/O 등 자원을 제한하고 관리할 수 있게 한다.
        >    - ex) CPU 자원 제한, 메모리 사용량 설정
        >3. 파일 시스템 격리
        
3. 이식성
    - 애플리케이션 + 종속성을 하나의 패키지로 묶는다 → 어디서든 동일한 방식으로 실행된다.
    - local 개발환경 → 서버/클라우드 환경으로 손쉽게 이식할 수 있다.
4. 빠른 배포/관리
    - 컨테이너는 단위가 작고 독립적이다 → 애플리케이션을 빠르게 배포하고 확장할 수 있다.
    - 컨테이너 오케스트라 툴을 사용하면, 여러 컨테이너를 자동으로 관리/확장할 수 있다.
        - ex) 쿠버네티스


## 2️⃣주제 2: Docker 개념

![image](https://github.com/user-attachments/assets/2f11b14a-10c6-418f-9958-f0dee806cc93)


### Docker 컨테이너/ Docker 이미지/ Dockerfile

1. **Docker 컨테이너**
    1. 이미지 기반으로 실행되는 ‘실제 프로세스’
    2. ‘실행된 인스턴스’ 역할을 한다. → **이미지를 바탕으로 생성된 개별 실행 프로세스**
2. **Docker 이미지**
    1. 애플리케이션이 실행될 준비가 된 ‘snapshot’.
    2. Dockerfile을 기준으로 build
    3. ‘템플릿’ 역할을 한다. → **변경되지 않는 기준 상태**
    4. **레이어 구조**
        - 여러 개의 읽기 전용 layer로 구성된다. (append only)
        - Dockerfile에 있는 코드 한줄 한줄이 layer이
3. **DockerFile**
    1. 이미지를 생성하기 위한 설정파일.
    2. 도커 실행 시 자동으로 해당 파일을 read
    3. 사진을 찍는 행위 === docker build 을 수행하는 것
    
    ```markdown
    1. FROM    : 베이스 이미지 지정
    2. RUN     : 컨테이너 내에서 명령어 실행
    3. CMD     : 컨테이너가 시작될 때 실행할 명령어 지정
    4. COPY    : 파일을 호스트 시스템에서 이미지로 복사
    5. WORKDIR : DockerFile 내에서 작업 디렉토리를 설정
    ```
    
4. Registry
    1. 도거 이미지를 저장/배포 하는 저장

## 3️⃣주제 3: Docker 기본 실행 명령어

### 1. Docker 이미지 빌드

```markdown
# Dockerfile이 있는 디렉토리에서 실행
docker build -t my-node-app -f Dockerfile.test2 .
```

- -t my-node-app : 이미지 이름을 ‘my-node-app’ 으로 지정
- -f Dockerfile.test2 : 사용할 DockerFile 지정
- . : 빌드 컨텍스트 (현재 디렉토리)

### 2. 컨테이너 실행하기

```markdown
# 기본실행
docker run my-node-app

# 백그라운드 실행
docker run -d my-node-app

# 포트 매핑 (ex. 3000번 포트 사용)
docker run -p 3000:3000 my-node-app
```

### 유용한 명령어들

```markdown
# 빌드된 이미지 확인
docker images

# 실행중인 컨테이너 확인
docker ps

# 모든 컨테이너 확인 (중지 포함)
docker ps -a

# 컨테이너 중지
docker stop [container_id]

# 컨테이너 삭제
docker rm [container_id]
```

### 오늘의 회고
