# TIL Template

## 날짜: 2024-11-20

### 스크럼

- 학습 목표 1 : 게시글 작성 데이터 res+req

### 새로 배운 내용

### 1️⃣주제 1: 트랜잭션 + ACID

## 트랜잭션
DB에서 상태를 변화시키기 위한 하나의 논리적 작업 단위

### ❓상태를 변화시킨다?

SQL(SELECT,INSERT,UPDATE)을 사용해 DB 데이터에 접근한다. 데이터 삽입, 수정..etc 으로 DB에 변화가 생긴다.

### ❓작업 단위?

작업의 단위는 단일 명령문이 아니라, **여러 개의 명령문으로 이뤄질 수 있다.**

⇒ 하나의 ‘논리적’ 작업을 수행하기 위해 여러 줄의 SQL 명령문을 묶어 처리할 수 있다.

ex) 게시판 - **댓글 작성**

```sql
## 트랜잭션 시작

**1. 댓글 내용을 comment 테이블에 추가**
INSERT INTO comments (post_id, author, content, created_at) 
VALUES (1, '홍길동', '이 게시물 정말 좋아요!', NOW());

**2. 해당 post 테이블에 댓글 수 +1**
UPDATE posts 
SET comment_count = comment_count + 1 
WHERE id = 1;

## 트랜잭션 성공 (commit)
```
⇒ 여러 작업을 묶어 하나의 논리적 작업으로 수행할 수 있다.

### 왜 트랜잭션을 사용해야하는가?

1. 데이터의 신뢰성과 무결성을 보장한다
    
    → 데이터가 예상한 대로 들어있고, 잘못된 상태로 변경되지 않도록 보장.
    
2. 데이터를 일관성 있게 안정적으로 복구 할 수 있다.
3. 여러 사용자가 데이터를 동시에 접근할 때 충돌 없이 안정적으로 데이터를 처리할 수 있다.
4. 작업의 일관된 처리를 보장한다.

## ACID
1. 트랜잭션을 사용할 때 반드시 지켜야 하는 **핵심 원칙**
2. ACID을 따르면 DB의 신뢰성과 무결성을 보장할 수 있다.

### 1. Atomicity (원자성)
 **ALL or Nothing**

1. 트랜잭션의 작업은 **모두 성공하거나 실패**한다.
2. 만약 작업 도중 오류가 난다면 모든 작업을 취소하고 시작 전으로 돌아간다. (ROLLBACK)

ex) 댓글작성

```sql
## 트랜잭션 시작

1. 댓글 내용을 comment 테이블에 추가

2. 해당 post 테이블에 댓글 수 +1 => !도중에 오류 발생!

3. (1번 작업은 취소). + 트랜잭션 시작 전으로 돌아 간다.
```

### 2. Consistency (일관성)
Preserving database invariants

1. 트랜잭션 수행 전 후로 DB는 **항상 일관된 상태를 유지**한다.
    
    ⇒ 트랙잭션을 수행하기 전과 후의 데이터가 항상 정해진 규칙과 제약을 만족해야한다.
    

ex) 

```sql
※ 제약조건 : 게시물 댓글 수와 comment 테이블에 저장된 댓글 수가 일치해야한다.

## 댓글 추가 전 : post 댓글 2개, comment 테이블 댓글 갯수 2개

## 트랜잭션 시작
1. 댓글 추가 트랜잭션을 수행한다. (댓글 comment 테이블에 추가 + 해당 post 댓글 수+1)

2, 댓글 수와 comment 테이블에 저장된 댓글 수가 일치한지 확인 
		=> !post 댓글은 2개, comment 테이블은 3개! (오류 발생)
		
3.*일관성이 깨졌으므로, 트랜잭션 시작 전으로 돌아 간다.
```

### 3. Isolation (고립성)

- 동시에 트랜잭션이 수행된다면 트랜잭션은 서로 영향을 받지 않는다.
- 각 트랜잭션은 다른 트랜잭션과 **독립적으로 수행**된다.

ex) 유저 A와 유저 B가 같은 게시물에 댓글을 동시에 작성하는 상황

```sql
## 초기상태 : post 댓글 5개 comment 테이블 post 댓글 갯수 5개

1. 유저 A가 게시물에 댓글을 달았다.
	## 트랜잭션 시작
	1) 댓글 comment 테이블에 추가  => **if 유저A의 트랜잭션이 끝나기전에 B의 트랜잭션이 시작됐다.**
	2) post 댓글 수 +1  (5 -> 6개) 
	
2. 유저 B가 게시물에 댓글을 달았다.
	## 트랜젝션 시작
	1) 댓글 comment 테이블 에 추가
	2) post 댓글 수 +1 **=> (A의 댓글이 반영되지 않았다면, 6->7개가 아닌 5->6개로 갱신된다.)
	
	=> 데이터의 일관성이 깨지게 된다.
	
	⇒ 유저A 트랜잭션과 유저B 트랜잭션은 서로 격리되어 실행되어야 한다.**
	고립성을 보장하기 위해 격리수준을 설정해야한다.
	****
```

### 4. Durability (지속성)

- 트랜잭션이 성공적으로 완료되면, 결과는 영구적을 저장된다.
- 완료가 됐다면, 시스템 장애가 발생하더라도 데이터를 보장한다.

ex)

```sql
1) 유저A가 댓글을 작성했다.

## 트랜잭션 시작

1. 댓글 내용을 comment 테이블에 추가

2. 해당 post 테이블에 댓글 수 +1

## 트랜잭션 성공 (commit)

2) 트랜잭션이 commit이 되면 댓글 내용과 댓글 수 작업은 영구적으로 DB에 저장된다.

3) IF 시스템이 다운 되어 다시 시작했다. -> **데이터가 여전히 DB에 저장되어 있다.
	 (트랜잭션 로그를 읽고 commit 된 트랜잭션을 다시 적용)

4) IF commit이 되기 전에 시스템이 다운됐다? -> rollback
```

### 언제 트랜잭션을 사용하는가?
1. 여러 작업을 묶어서 처리할 때
2. 데이터 일관성을 보장해야 할때
3. 동시성 제어가 필요할때
- **단일 작업, 데이터 조회 같은 작업은 트랜잭션을 사용하지 않아도 된다. (원자성, 일관성의 문제가 발생하지 않는다.)**
  
---


### 오늘의 회고

기능 별로 짧게 commit하는 습관을 가져야겠다!!

express-session에 대해 더 공부하고 싶다🔥🔥🔥

### 참고 자료 및 링크
